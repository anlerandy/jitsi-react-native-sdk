"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.maybeRedirectToTokenAuthUrl = exports.reloadWithStoredParams = exports.redirectToStaticPage = exports.redirectWithStoredParams = void 0;
// @ts-ignore
// eslint-disable-next-line
const actions_1 = require("../authentication/actions");
// @ts-ignore
const functions_1 = require("../authentication/functions");
const functions_2 = require("../base/jwt/functions");
const constants_1 = require("../base/media/constants");
const functions_any_1 = require("../base/tracks/functions.any");
const uri_1 = require("../base/util/uri");
const functions_any_2 = require("./functions.any");
const logger_1 = __importDefault(require("./logger"));
/**
 * Redirects to another page generated by replacing the path in the original URL
 * with the given path.
 *
 * @param {(string)} pathname - The path to navigate to.
 * @returns {Function}
 */
function redirectWithStoredParams(pathname) {
    return (dispatch, getState) => {
        const { locationURL } = getState()['features/base/connection'];
        const newLocationURL = new URL(locationURL?.href ?? '');
        newLocationURL.pathname = pathname;
        window.location.assign(newLocationURL.toString());
    };
}
exports.redirectWithStoredParams = redirectWithStoredParams;
/**
 * Assigns a specific pathname to window.location.pathname taking into account
 * the context root of the Web app.
 *
 * @param {string} pathname - The pathname to assign to
 * window.location.pathname. If the specified pathname is relative, the context
 * root of the Web app will be prepended to the specified pathname before
 * assigning it to window.location.pathname.
 * @param {string} hashParam - Optional hash param to assign to
 * window.location.hash.
 * @returns {Function}
 */
function redirectToStaticPage(pathname, hashParam) {
    return () => {
        const windowLocation = window.location;
        let newPathname = pathname;
        if (!newPathname.startsWith('/')) {
            // A pathname equal to ./ specifies the current directory. It will be
            // fine but pointless to include it because contextRoot is the current
            // directory.
            newPathname.startsWith('./')
                && (newPathname = newPathname.substring(2));
            newPathname = (0, uri_1.getLocationContextRoot)(windowLocation) + newPathname;
        }
        if (hashParam) {
            windowLocation.hash = hashParam;
        }
        windowLocation.pathname = newPathname;
    };
}
exports.redirectToStaticPage = redirectToStaticPage;
/**
 * Reloads the page by restoring the original URL.
 *
 * @returns {Function}
 */
function reloadWithStoredParams() {
    return (dispatch, getState) => {
        const state = getState();
        const { locationURL } = state['features/base/connection'];
        // Preserve the local tracks muted states.
        // @ts-ignore
        const newURL = (0, functions_any_2.addTrackStateToURL)(locationURL, state);
        const windowLocation = window.location;
        const oldSearchString = windowLocation.search;
        windowLocation.replace(newURL.toString());
        if (newURL.search === oldSearchString) {
            // NOTE: Assuming that only the hash or search part of the URL will
            // be changed!
            // location.replace will not trigger redirect/reload when
            // only the hash params are changed. That's why we need to call
            // reload in addition to replace.
            windowLocation.reload();
        }
    };
}
exports.reloadWithStoredParams = reloadWithStoredParams;
/**
 * Checks whether tokenAuthUrl is set, we have a jwt token that will expire soon
 * and redirect to the auth url to obtain new token if this is the case.
 *
 * @param {Dispatch} dispatch - The Redux dispatch function.
 * @param {Function} getState - The Redux state.
 * @param {Function} failureCallback - The callback on failure to obtain auth url.
 * @returns {boolean} Whether we will redirect or not.
 */
function maybeRedirectToTokenAuthUrl(dispatch, getState, failureCallback) {
    const state = getState();
    const config = state['features/base/config'];
    const { enabled: audioOnlyEnabled } = state['features/base/audio-only'];
    const { startAudioOnly } = config;
    const { locationURL = { href: '' } } = state['features/base/connection'];
    const audioMuted = (0, functions_any_1.isLocalTrackMuted)(state['features/base/tracks'], constants_1.MEDIA_TYPE.AUDIO);
    const videoMuted = (0, functions_any_1.isLocalTrackMuted)(state['features/base/tracks'], constants_1.MEDIA_TYPE.VIDEO);
    if (!(0, functions_1.isTokenAuthEnabled)(config)) {
        return false;
    }
    // if tokenAuthUrl check jwt if is about to expire go through the url to get new token
    const jwt = state['features/base/jwt'].jwt;
    const expirationDate = (0, functions_2.getJwtExpirationDate)(jwt);
    // if there is jwt and its expiration time is less than 3 minutes away
    // let's obtain new token
    if (expirationDate && expirationDate.getTime() - Date.now() < 3 * 60 * 1000) {
        const room = state['features/base/conference'].room;
        const { tenant } = (0, uri_1.parseURIString)(locationURL.href) || {};
        (0, functions_1.getTokenAuthUrl)(config, locationURL, {
            audioMuted,
            audioOnlyEnabled: audioOnlyEnabled || startAudioOnly,
            skipPrejoin: true,
            videoMuted
        }, room, tenant)
            .then((tokenAuthServiceUrl) => {
            if (!tokenAuthServiceUrl) {
                logger_1.default.warn('Cannot handle login, token service URL is not set');
                return Promise.reject();
            }
            return dispatch((0, actions_1.openTokenAuthUrl)(tokenAuthServiceUrl));
        })
            .catch(() => {
            failureCallback();
        });
        return true;
    }
    return false;
}
exports.maybeRedirectToTokenAuthUrl = maybeRedirectToTokenAuthUrl;
